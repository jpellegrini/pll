<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>PLL: Programming in Logic in Lisp</title>
  <style type="text/css">code{white-space: pre;}</style>
  <meta name="keywords" content="prolog,programming in logic,lisp"> <meta name="description" content="PLL -- Programming in Logic in Lisp"> <link rel="icon" type="image/x-icon" href="favicon.ico" /> <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">PLL: Programming in Logic in Lisp</h1>
</div>
<h1 id="pll-programming-in-logic-in-lisp">PLL: Programming in Logic in Lisp</h1>
<p>PLL is a simple Prolog in Scheme, developed as a teaching aid. It is supposed to make it easy to understand the execution model of Prolog, including variables, cuts, and meta-predicates. There is also a simple FFI to Scheme.</p>
<p>When I say &quot;simple&quot;, I really mean it. This implementation is NOT efficient at all, and it misses several features. The manual is also very basic, although it covers most of what really matters.</p>
<p>The code is documented, but not &quot;densely documented&quot; -- this is mostly because the interpreter was developed as an auxiliary tool for a course, and the implementation details are explained in the course notes which were written in Portuguese. However, the code may be used as a companion to chapter 4 of Sterling and Shapiro's &quot;The Art of Prolog&quot;, as it closely follows the execution model explained there.</p>
<h2 id="loading-pll">LOADING PLL</h2>
<p>There are two ways to use PLL. In implementations that support R7RS, you can import it. This may be useful if you want to rename identifiers. In implementations that do not support R7RS, there is a file that will load the interpreter.</p>
<pre><code>(load &quot;pll-standalone.scm&quot;)    ;; this works on all supported schemes.

(import (pll))                 ;; only on the systems marked as having
                               ;; support for R7RS modules</code></pre>
<h2 id="variables">VARIABLES</h2>
<p>Traditionally, Prolog systems treat symbols beginning with uppercase letters as variables: X, Y, Variable are variables, while x, y, constant are constants.</p>
<p>Lisp-based Prologs usually do this differently: the variables are the symbols that begin with a question mark: <code>?x</code>, <code>?y</code>, <code>?variable</code>, etc. We do the same in this implementation.</p>
<h2 id="calling-the-interpreter">CALLING THE INTERPRETER</h2>
<p>Our Prolog use the following syntax:</p>
<pre><code>(pure-prolog PROGRAM GOAL)</code></pre>
<p>The program is a list of assertions. The program</p>
<pre><code>         p(x).
         p(Z) :- q, r(Z).</code></pre>
<p>is written as a list of assertions. Each assertion is a list where the head represents the left side (the consequent), and the tail is a list of the goals to be met in order to prove the consequent. For example,</p>
<pre><code>        &#39;(( (p x) ))
          ( (p ?z) q (r ?z)))</code></pre>
<p>The GOAL is a list of goals:</p>
<pre><code>        p(1), q(X).</code></pre>
<p>is written as</p>
<pre><code>        &#39;((p 1) (q ?x))</code></pre>
<p>EXAMPLE: Suppose we want to enter the following program:</p>
<pre><code>f(0).
f(Z) :- g(Z).
h(3).
h(4).
p(Z,Y,S) :- f(Z),g(Y),h(S)
g(10).</code></pre>
<p>And ask the question</p>
<pre><code>p(10,D,A), q(A).</code></pre>
<p>We can do this:</p>
<pre><code>(define facts &#39;(( (f 0) )
                ( (f ?z) (g ?z) )
                ( (h 3) )
                ( (h 4) )
                ( (q 4) )
                ( (p ?z ?y ?s) (f ?z) (g ?y) (h ?s) )
                ( (g 10) )))
(define goals &#39;((p 10 ?d ?a) (q ?a)))</code></pre>
<p>And call</p>
<pre><code>(pure-prolog facts goals)</code></pre>
<p>Or, directly enter the facts and goal (as we do in the examples that are included in <code>prolog-examples.scm</code>):</p>
<pre><code>(pure-prolog &#39;(( (f 0) )
               ( (f ?z) (g ?z))
               ( (h 3) )
               ( (h 4) )
               ( (q 4) )
               ( (p ?z ?y ?s) (f ?z) (g ?y) (h ?s))
               ( (g 10) ))
             &#39;((p 10 ?d ?a) (q ?a)))</code></pre>
<p>The result will be a list of substitutions that satisfy the goal:</p>
<pre><code>((?a . 4) (?d . 10))</code></pre>
<h2 id="getting-multiple-answers">GETTING MULTIPLE ANSWERS</h2>
<p>This can be done with the <code>amb+</code> operator.</p>
<pre><code>(pure-prolog &#39;(((f 1))
               ((f 2)))
             &#39;((f ?x)))

((?x 1))</code></pre>
<p>If we call <code>(amb+)</code>, then we get another solution:</p>
<pre><code>((?x 2))</code></pre>
<h2 id="different-interpreters">DIFFERENT INTERPRETERS</h2>
<p>The different interpreters included are:</p>
<ul>
<li><code>pure prolog</code> (prolog only)</li>
<li><code>prolog+built-ins</code> (with built-in predicates with side-effect)</li>
<li><code>prolog+scheme</code> (with an FFI to Scheme, but NO built-ins)</li>
<li><code>prolog+local</code> (with &quot;IS&quot; and local vars; on top of prolog+scheme)</li>
<li><code>prolog+meta</code> (with assert and retract; on top of prolog+local)</li>
<li><code>prolog+cut</code> (with cut (!); on top of prolog+meta)</li>
</ul>
<p>So the features are added one on top of the other, except for the built-ins feature, which is not included in the later interpreters.</p>
<p>In the source code, there is one initial implementation (pure-prolog) with short comments explaining how it works. Each interpreter after that one has comments only on the modified parts.</p>
<h3 id="pure-prolog">Pure Prolog</h3>
<p>This is the most basic of all. You can only statet facts as we described above, nothing else. Call it as</p>
<pre><code>(pure-prolog facts goals)</code></pre>
<p>For example, we define a graph by declaring its edges, then define a <code>reach/2</code> predicate.</p>
<pre><code>edge(a,b).
edge(a,c).
edge(c,b).
edge(c,d).
edge(d,e).
reach(A,B) :- edge(A,B).
reach(A,B) :- edge(A,X), reach(X,B).</code></pre>
<p>We could then as &quot;<code>reach(b,e)</code>&quot; and find that <em>b</em> doesn't reach <em>e</em>.</p>
<p>In PLL:</p>
<pre><code>(define graph &#39;( ((edge a b))
                 ((edge a c))
                 ((edge c b))
                 ((edge c d))
                 ((edge d e))
                 ((reach ?a ?b) (edge ?a ?b))
                 ((reach ?a ?b) (edge ?a ?x)
                                (reach ?x ?b))))

(pure-prolog graph &#39;( (reach b e) ))
#f</code></pre>
<h3 id="prolog-with-built-in-procedures">Prolog with built-in &quot;procedures&quot;</h3>
<p>This adds some predicates with side-effects.</p>
<p>Define a list of Scheme functions that you want to be accessible from Prolog:</p>
<pre><code>(define write-it
  (lambda (args sub)
    (cond ((not (null? args))
           (if (matching-symbol? (car args))
               (display (assoc (car args) sub))
               (display (car args)))
           (write-it (cdr args) sub))
          (else #t))))</code></pre>
<p>Here &quot;<code>sub</code>&quot; is the current substitution, where Prolog will find the values of variables.</p>
<pre><code>(define built-ins `((write . ,write-it)))</code></pre>
<p>So <code>(write a b c ...)</code> will be translated to</p>
<pre><code>(write-it (a b c ...) sub)</code></pre>
<p>Then, whenever one of these predicates show up in the goal, Prolog will execute them:</p>
<pre><code>father(john,johnny).
father(old-john,john).
grandpa(A,B) :- father(A,X), father(X,B).</code></pre>
<p>Our goal is</p>
<pre><code>grandpa(old-john,Who), write(&quot;grandson is: &quot;), write(Who).</code></pre>
<p>In our Prolog, this is expressed as follows:</p>
<pre><code>(prolog+built-ins &#39;( ((father john johnny))
                     ((father old-john john))
                     ((grandpa ?a ?b) (father ?a ?x) (father ?x ?b)) )
                  &#39;( (grandpa old-john ?who)  (write &quot;Grandson is: &quot; ?who) ))

Grandson is: johnny
(((?who . johnny)) ())</code></pre>
<p>The first line was the effect of having a <code>(write ...)</code> in the goal. The second is the answer.</p>
<h3 id="prolog-with-any-scheme-function">Prolog with any scheme function</h3>
<p>This interpreter has no sandbox -- it will recognize and execute any Scheme function when it sees one.</p>
<p>Suppose we want to run this Prolog program, and use a Scheme function &quot;<code>print</code>&quot; in the goal:</p>
<pre><code>a(5).
b(3).
b(5).</code></pre>
<p>Goal:</p>
<pre><code>a(X), b(Y), X=Y, print(X, &quot; &quot; Y).</code></pre>
<p>In our Prolog, we have:</p>
<pre><code>(prolog+scheme &#39;( ((a 5))
                  ((b 3))
                  ((b 5)))
               &#39;( (a ?x) (b ?y) ((= ?x ?y)) ((print ?x &quot; &quot; ?y))))

5 5
((?y . 5) (?x . 5))</code></pre>
<p>The first line is the effect of the print. The second line is Prolog's answer.</p>
<h3 id="with-local-variables">With local variables</h3>
<pre><code>(prolog+local &#39;( ((f ?x ?y)
                  (is ?y (* 2 ?x))
                  ((print &#39;OK: ?y))))
              &#39;( (f 3 ?a) ))

OK:6
((?a . 6))</code></pre>
<h3 id="with-assert-and-retract">With assert and retract</h3>
<p>This adds the meta-predicates <code>assert</code> and <code>retract</code>.</p>
<pre><code>(prolog+meta &#39;(( (f ?x) (asserta (h 1)))
               ( (g ?x) (h ?x)))
             &#39;((f ?w) (g ?z)))</code></pre>
<p>The result will be <code>((?z . 1))</code></p>
<p><code>retract</code> has the opposite effect. The Prolog program we show now is</p>
<pre><code>f(2).
f(3).
g(1) :- retract(f(2)).</code></pre>
<p>And the goal is</p>
<pre><code>g(1), f(X).</code></pre>
<p>In PPL's Schemish-Prolog, this is</p>
<pre><code>(define prolog-retract &#39;( ((f 2))
                          ((f 3))
                          ((g 1) (retract ((f 2))))
                          ((g 1) (f 3))))
(prolog+meta prolog-retract &#39;((g 1) (f ?x)))</code></pre>
<p><code>(g 1)</code> causes retract to be evaluated, so the goal succeeds with <em>X=3</em>, and not <em>X=2</em>:</p>
<pre><code>((?x 3))</code></pre>
<h3 id="with-cut">With cut</h3>
<p>This adds the cut operator. For example, in Prolog we could write</p>
<pre><code>a(X) :- b(X), !, c(X).
b(1).
b(2).
c(2).</code></pre>
<p>The goal <code>a(X)</code> fails, because after the interpreter chooses <code>b(1)</code>, it cannot backtrack, and <code>c(1)</code> is not true.</p>
<p>In our Prolog, we write:</p>
<pre><code>(prolog+cut &#39;(( (a ?x) (b ?x) ! (c ?x) )
              ( (b 1) )
              ( (b 2) )
              ( (c 2) ))
            &#39;((a ?x)))

#f</code></pre>
<p>If we remove the cut, then this goal will succeed with <em>X=2</em>.</p>
<p>The cut can be used also in the goal.</p>
<h2 id="bugs-and-missing-features">BUGS AND MISSING FEATURES</h2>
<ul>
<li><p>There is no way to save and load the database</p></li>
<li><p>There is no simple way to get all possible answers (substitutions) for a query in a list.</p></li>
<li><p>This manual is too short.</p></li>
</ul>
<h2 id="a-bibliography">A BIBLIOGRAPHY</h2>
<p>The following is a list of some books related to Prolog programming and implementations of Prolog.</p>
<ol style="list-style-type: decimal">
<li><p><strong><em>William Clocksin, Chris Mellish</em></strong>. <em>&quot;Programming in Prolog&quot;</em>. Springer, 2003. [ a very basic text ]</p></li>
<li><p><strong><em>Michael Covington, Donald Nute, André Vellino</em></strong>. <em>&quot;Prolog Programming in Depth&quot;</em>. Scott, Foresman and Company, 1988. [ quick introduction to Prolog, followed by some advanced programming techniques and application ]</p></li>
<li><p><strong><em>Leon Sterling, Ehud Shapiro</em></strong>. <em>&quot;The Art of Prolog&quot;</em>. MIT Press, 1994. [ solid introduction to Prolog, including the execution model -- strongly recommended for those who want to understand the internals of the interpreter ]</p></li>
<li><p><strong><em>Richard O'Keefe</em></strong>, <em>&quot;The Craft of Prolog&quot;</em>. MIT Press, 1990. [ advanced programming techniques ]</p></li>
<li><p><strong><em>Harold Abelson, Gerald Jay Sussman</em></strong>. <em>&quot;Structure and Interpretation of Computer Programs&quot;</em>. Addison-Wesley, 1996. [ explains and implements in Scheme the AMB operator and a small Prolog interpreter ]</p></li>
<li><p><strong><em>Peter Norvig</em></strong>. <em>&quot;Paradigms of Artificial Intelligence Programming&quot;</em>. Morgan Kaufmann, 1992. [ part of the book explains unification and contains another Prolog implementation, in Common Lisp ]</p></li>
<li><p><strong><em>Jacques Chazarain</em></strong>, <em>&quot;Programmer Avec Scheme&quot;</em>. International Thomson Publishing France, 1996 (in French). [ a very good book on Scheme. chapters 15-19 focus on Prolog ]</p></li>
<li><p><strong><em>J. A. Campbell</em></strong>. <em>&quot;Implementations of PROLOG&quot;</em>. Ellis Horwood, 1984. [ a study of implementation techniques. quite advanced. ]</p></li>
</ol>
</body>
</html>
